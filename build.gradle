plugins {
	id 'c'
	id 'cpp'
	id 'cunit-test-suite'
	id 'cppunit-test-suite'
	id 'windows-resources'
	id 'windows-messages'
	id 'visual-studio'
}

/*
class BinaryCollectorPlugin extends RuleSource {
	@Mutate
	public void createCollectBinariesTask(ModelMap<Task> tasks, @Path("binaries") ModelMap<NativeBinarySpec> binaries) {
        tasks.create('collectBinaries', Copy) { task ->
            binaries.each { binary ->
                task.dependsOn binary.buildTask
                
                String buildType = binary.buildType.name
 				destinationDir = project.rootProject.rootDir

               if (binary instanceof NativeExecutableBinarySpec) {
                    addBinary(task, binary.file, buildType, 'bin')
                } else if (binary instanceof SharedLibraryBinarySpec) {
                    addBinary(task, binary.sharedLibraryFile, buildType, 'bin')
				} else if (binary instanceof StaticLibraryBinarySpec) {
                    addBinary(task, binary.staticLibraryFile, buildType, 'lib')
				}
            }
        }
    }
    
    private void addBinary(Copy task, File binaryFile, String buildType, String destinationDirectory) {
        task.from(binaryFile) {
            into destinationDirectory
			System.err.println("Adding binary $binaryFile to $destinationDirectory");
           
            if (buildType == 'debug') {
                rename { originalName ->
                    int lastPeriod = originalName.lastIndexOf('.')
                    
                    if (lastPeriod < 0)
                        return "Poco" + originalName
                    else {
                        String fileName = originalName.substring(0, lastPeriod)
                        String extension = originalName.substring(lastPeriod + 1)
                        
                        return "Poco" + "${fileName}d.$extension"
                    }
                }
            }
        }
    }
}
apply plugin: BinaryCollectorPlugin

*/

//tasks.build.dependsOn collectBinaries

task wrapper(type: Wrapper) {
	gradleVersion = '3.1'
}


allprojects {
	apply plugin:  'c'
	apply plugin:  'cpp'
	apply plugin:  'visual-studio'
	apply plugin:  'cunit-test-suite'
	apply plugin:  'cppunit-test-suite'

	buildDir = new File("gradle")	
	
   def addCompilerFlag = { NativeBinarySpec binary, String flag ->
        if (binary.hasProperty("cppCompiler")) {
            binary.cppCompiler.args flag
        }
        if (binary.hasProperty("cCompiler")) {
            binary.cCompiler.args flag
        }
    }
    
    def addCompilerDefine = { NativeBinarySpec binary, String define, String value ->
        if (binary.hasProperty("cppCompiler")) {
            binary.cppCompiler.define define, value
        }
        if (binary.hasProperty("cCompiler")) {
            binary.cCompiler.define define, value
        }
    }

	model {
/*
	   all {
			binaries.withType(NativeBinarySpec).afterEach { binary ->
				def headers = binary.libs.collect { it.includeRoots }
			}
		}
*/
		buildTypes {
			debug
//	        release
		}

		
		platforms {
			win32 {
				operatingSystem "windows"
				architecture 'x86'
			}
			win64 {
				operatingSystem "windows"
				architecture 'x86_64'
			}
			linux32 {
				operatingSystem "linux"
				architecture 'x86'
			}
			linux64 {
				operatingSystem "linux"
				architecture 'x86_64'
			}
		}

		flavors {
	 //       minimal
			unbundled
		}
		
		binaries {
			all {
				if (flavor == flavors.unbundled) {
					cppCompiler.define 'PPPPPOCO_UNBUNDLED'
				}
				if (buildTypes == buildTypes.debug) {
					cCompiler.define '_DEBUG'
					cppCompiler.define '_DEBUG'
				} else {
					cCompiler.define 'NDEBUG'
					cppCompiler.define 'NDEBUG'
				}
			
				if (toolChain in VisualCpp) {
					if (buildTypes == buildTypes.debug) {
						cCompiler.args '/Zi'
						cppCompiler.args '/Zi'
						linker.args '/DEBUG'
					}
					cCompiler.args '/Zc:wchar_t'
					cCompiler.args '/Zc:inline'
					cCompiler.args '/Zc:forScope'
					cCompiler.args '/GR'
					cCompiler.args '/GF'
					cCompiler.args '/EHsc'
					cCompiler.define 'WIN32'
					cCompiler.define '_WIN32'
					cCompiler.define '_WINDOWS'
					cCompiler.define '_MBCS'

					cppCompiler.args '/Zc:wchar_t'
					cppCompiler.args '/Zc:inline'
					cppCompiler.args '/Zc:forScope'
					cppCompiler.args '/GR'
					cppCompiler.args '/GF'
					cppCompiler.args '/EHsc'
					cppCompiler.define 'WIN32'
					cppCompiler.define '_WIN32'
					cppCompiler.define '_WINDOWS'
					cppCompiler.define '_MBCS'
				
					linker.args 'kernel32.lib'
					linker.args 'user32.lib'
					linker.args 'gdi32.lib'
					linker.args 'comdlg32.lib'
					linker.args 'advapi32.lib'
					linker.args 'shell32.lib'
					linker.args 'ole32.lib'
					linker.args 'oleaut32.lib'
					linker.args 'uuid.lib'
				
					if (buildTypes == buildTypes.debug) {
						cCompiler.args "/MDd"
						cppCompiler.args "/MDd"
					} else {
						cCompiler.args "/MD"
						cppCompiler.args "/MD"
					}
					linker.args '/SUBSYSTEM:CONSOLE'
				}
			}
			withType(SharedLibraryBinarySpec) {
				if (toolChain in VisualCpp) {
					cCompiler.define '_USRDLL'
					cCompiler.define '_WINDLL'
					cppCompiler.define '_USRDLL'
					cppCompiler.define '_WINDLL'
				}
			}
			withType(StaticLibraryBinarySpec) {
				if (toolChain in VisualCpp) {
					cCompiler.define 'POCO_STATIC'
					cppCompiler.define 'POCO_STATIC'
				}
			}
			withType(NativeExecutableSpec) {
				if (toolChain in VisualCpp) {
					
				}
			}
		}
	}
}

subprojects {
 	apply plugin:	'windows-resources'
	apply plugin:	'windows-messages'
}

gradle.afterProject {project, projectState ->
    if (projectState.failure) {
        println "Evaluation of $project FAILED"
    } else {
        println "Evaluation of $project succeeded"
    }
}