plugins {
	id 'c'
	id 'cpp'
	id 'cunit-test-suite'
	id 'cppunit-test-suite'
	id 'windows-resources'
	id 'windows-messages'
	id 'visual-studio'
}


//tasks.build.dependsOn collectBinaries

repositories {
	mavenCentral()
}

/*
dependencies {
	testCompile group: 'org.jvnet.hudson.plugins', name: 'cppunit', version: '1.10'
}
*/

File appendDebugSuffix(File binaryFile) {
	String name = binaryFile.getName()
	File parent = binaryFile.getParentFile()
	int extensionSeparatorIndex = name.lastIndexOf('.')
	return new File(parent, name.substring(0, extensionSeparatorIndex) + "d" + name.substring(extensionSeparatorIndex))
}

File prefixByPoco(File binaryFile) {
	String name = binaryFile.getName()
	File parent = binaryFile.getParentFile()
	return new File(parent, "Poco" + name);
}
allprojects {
	buildDir = new File("gradle")	
}
subprojects {
	apply plugin:	'c'
	apply plugin:	'cpp'
	apply plugin:	'visual-studio'
	apply plugin:	'cunit-test-suite'
	apply plugin:	'cppunit-test-suite'
 	apply plugin:	'windows-resources'
	apply plugin:	'windows-messages'

	
		model {
			buildTypes {
				release
				debug
			}
			components {
				withType(NativeComponentSpec) {
					binaries.withType(NativeBinarySpec) {
						if (buildType == buildTypes.debug) {
							if (it instanceof SharedLibraryBinarySpec) {
								sharedLibraryFile = prefixByPoco(appendDebugSuffix(sharedLibraryFile))
								sharedLibraryLinkFile = prefixByPoco(appendDebugSuffix(sharedLibraryLinkFile))
							} else
							if (it instanceof StaticLibraryBinarySpec) {
								staticLibraryFile = prefixByPoco(appendDebugSuffix(staticLibraryFile))
							} else
							if (it instanceof NativeExecutableBinarySpec) {
								// executable.file = ...
							} else {
								throw new GradleException("Unknown native library binary")
							}
						} else
						if (buildType == buildTypes.release) {
							if (it instanceof SharedLibraryBinarySpec) {
								sharedLibraryFile = prefixByPoco(sharedLibraryFile)
								sharedLibraryLinkFile = prefixByPoco(sharedLibraryLinkFile)
							} else
							if (it instanceof StaticLibraryBinarySpec) {
								staticLibraryFile = prefixByPoco(staticLibraryFile)
							} else
							if (it instanceof NativeExecutableBinarySpec) {
								// executable.file = ...
							} else {
								throw new GradleException("Unknown native library binary")
							} 
						} else {
							throw new GradleException("Unknown buildType")
						}
					}
				}
			}
	    repositories {
	        libs(PrebuiltLibraries) {
				def opensslDir = "$rootDir/openssl"
	            crypto {
					headers.srcDir "$opensslDir/include"

	                binaries.withType(StaticLibraryBinary) {
						def libName = targetPlatform.operatingSystem.windows ? 'libeay32MD.lib' : 'libssl.a'
	                    staticLibraryFile = file("$opensslDir/win32/bin/release/$libName")
					}
				}
	            ssl {
					headers.srcDir "$opensslDir/include"

	                binaries.withType(StaticLibraryBinary) {
						def libName = targetPlatform.operatingSystem.windows ? 'ssleay32MD.lib' : 'libssl.a'
	                    staticLibraryFile = file("$opensslDir/win32/bin/release/$libName")
   	             }
 	           }
 	       }
 	   }

/*
	   all {
			binaries.withType(NativeBinarySpec).afterEach { binary ->
				def headers = binary.libs.collect { it.includeRoots }
			}
		}
*/
		
		platforms {
			win32 {
				operatingSystem "windows"
				architecture 'x86'
			}
			win64 {
				operatingSystem "windows"
				architecture 'x86_64'
			}
			linux32 {
				operatingSystem "linux"
				architecture 'x86'
			}
			linux64 {
				operatingSystem "linux"
				architecture 'x86_64'
			}
		}

		flavors {
	 //       minimal
			unbundled
		}

		binaries {
			all {
				if (flavor == flavors.unbundled) {
					cppCompiler.define 'PPPPPOCO_UNBUNDLED'
				}
				if (buildType == buildTypes.debug) {
					cCompiler.define '_DEBUG'
					cppCompiler.define '_DEBUG'
				} else 
				if (buildType == buildTypes.release) {
					cCompiler.define 'NDEBUG'
					cppCompiler.define 'NDEBUG'
				} else {
					throw new GradleException("Unknown buildTypes" + buildTypes)
				}
			
				if (toolChain in VisualCpp) {
					if (buildType == buildTypes.debug) {
						cCompiler.args '/Zi'
						cppCompiler.args '/Zi'
						linker.args '/DEBUG'
					}
					cCompiler.args '/FS'
					cCompiler.args '/Zc:wchar_t'
					cCompiler.args '/Zc:inline'
					cCompiler.args '/Zc:forScope'
					cCompiler.args '/GR'
					cCompiler.args '/GF'
					cCompiler.args '/EHsc'
					cCompiler.define 'WIN32'
					cCompiler.define '_WIN32'
					cCompiler.define '_WINDOWS'
					cCompiler.define '_MBCS'

					cppCompiler.args '/FS'
					cppCompiler.args '/Zc:wchar_t'
					cppCompiler.args '/Zc:inline'
					cppCompiler.args '/Zc:forScope'
					cppCompiler.args '/GR'
					cppCompiler.args '/GF'
					cppCompiler.args '/EHsc'
					cppCompiler.define 'WIN32'
					cppCompiler.define '_WIN32'
					cppCompiler.define '_WINDOWS'
					cppCompiler.define '_MBCS'
				
					linker.args 'kernel32.lib'
					linker.args 'user32.lib'
					linker.args 'gdi32.lib'
					linker.args 'comdlg32.lib'
					linker.args 'advapi32.lib'
					linker.args 'shell32.lib'
					linker.args 'ole32.lib'
					linker.args 'oleaut32.lib'
					linker.args 'uuid.lib'
				
					if (buildType == buildTypes.debug) {
						cCompiler.args "/MDd"
						cppCompiler.args "/MDd"
					} else 
					if (buildType == buildTypes.release) {
						cCompiler.args "/MD"
						cppCompiler.args "/MD"
					} else {
						throw new GradleException("Unknown buildTypes" + buildTypes)
					}
					linker.args '/SUBSYSTEM:CONSOLE'
				}
			}
			withType(SharedLibraryBinarySpec) {
				if (toolChain in VisualCpp) {
					cCompiler.define   '_USRDLL'
					cCompiler.define   '_WINDLL'
					cppCompiler.define '_USRDLL'
					cppCompiler.define '_WINDLL'
				}
			}
			withType(StaticLibraryBinarySpec) {
				if (toolChain in VisualCpp) {
					cCompiler.define   '_LIB'
					cppCompiler.define '_LIB'
					cCompiler.define   'POCO_STATIC'
					cppCompiler.define 'POCO_STATIC'
				}
			}
			withType(NativeExecutableSpec) {
				if (toolChain in VisualCpp) {
					
				}
			}
		}
    }
}

/*
	def addCompilerFlag = { NativeBinarySpec binary, String flag ->
        if (binary.hasProperty("cppCompiler")) {
            binary.cppCompiler.args flag
        }
        if (binary.hasProperty("cCompiler")) {
            binary.cCompiler.args flag
        }
    }
    
    def addCompilerDefine = { NativeBinarySpec binary, String define, String value ->
        if (binary.hasProperty("cppCompiler")) {
            binary.cppCompiler.define define, value
        }
        if (binary.hasProperty("cCompiler")) {
            binary.cCompiler.define define, value
        }
    }

class BinaryCollectorPlugin extends RuleSource {
	@Mutate
	public void createCollectBinariesTask(ModelMap<Task> tasks, @Path("binaries") ModelMap<NativeBinarySpec> binaries) {
        tasks.create('collectBinaries', Copy) { task ->
            binaries.each { binary ->
                task.dependsOn binary.buildTask
                
                String buildType = binary.buildType.name
 				destinationDir = project.rootProject.rootDir

               if (binary instanceof NativeExecutableBinarySpec) {
                    addBinary(task, binary.file, buildType, 'bin')
                } else if (binary instanceof SharedLibraryBinarySpec) {
                    addBinary(task, binary.sharedLibraryFile, buildType, 'bin')
				} else if (binary instanceof StaticLibraryBinarySpec) {
                    addBinary(task, binary.staticLibraryFile, buildType, 'lib')
				}
            }
        }
    }
    
    private void addBinary(Copy task, File binaryFile, String buildType, String destinationDirectory) {
        task.from(binaryFile) {
            into destinationDirectory
			System.err.println("Adding binary $binaryFile to $destinationDirectory");
           
            if (buildType == 'debug') {
                rename { originalName ->
                    int lastPeriod = originalName.lastIndexOf('.')
                    
                    if (lastPeriod < 0)
                        return "Poco" + originalName
                    else {
                        String fileName = originalName.substring(0, lastPeriod)
                        String extension = originalName.substring(lastPeriod + 1)
                        
                        return "Poco" + "${fileName}d.$extension"
                    }
                }
            }
        }
    }
}
apply plugin: BinaryCollectorPlugin

*/
